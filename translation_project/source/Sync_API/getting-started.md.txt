# Getting started

In this section we will do some common things, that many of our users ask for help on accomplishing them. We will mostly use the sync call, which is described in detail at the Sync section. For now this can be considered as just an endpoint, and you will soon figure some of the things it can do, just by having a look at some examples.

## Get all projects

First, let’s see how we can get all projects a user has.

### Using curl

We send a request to the sync endpoint, and then specify the following arguments:

- The user’s API token, which here is set to token=0123456789abcdef0123456789abcdef01234567. You can find out your token from the Todoist Web app, at Todoist Settings -> Integrations -> API token.
- A special sync token, which denotes that we want a full sync, in contrast to an incremental sync, which is denoted with the * symbol, so we set sync_token=*.
- That we want to get back only the projects, and not any other data, so we set resource_types='["projects"]'.

In the results we get back, we notice the following data:

- All the user’s projects, which in this case it’s only the Inbox project.
- A special flag full_sync which is set to true here, and denotes we did a full sync.
- A new sync_token which we can use later on, in order to do incremental syncs.
- An empty temp_id_mapping object which we’ll look at later on.

### Using the Python library

We need to import the TodoistAPI class from the todoist module, create a TodoistAPI object which we store to the api variable, and specify our user API token, that is 0123456789abcdef0123456789abcdef01234567.

After that we can just do a sync by calling api.sync(), and we can access the user’s projects through the api.state object, so for projects that is: api.state['projects'].

## Excluding resource types

We’ve seen how we can get items selecting them with resource_types, but at the same time we can also exclude items. This can be done by adding a - before the name of the item you want to exclude.

For example, if we were making a request for everything but notes and labels, it’d look like this: resource_types=["all", "-notes", "-labels"].

### Using curl

Similar to our previous example, we’re sending a request to the sync endpoint with the following arguments:

- The user’s API token, which is set to token=0123456789abcdef0123456789abcdef01234567. You can find out your token from the Todoist Web app, at Todoist Settings -> Account -> API token.
- A special sync token, which denotes that we want a full sync, in contrast to an incremental sync, which is done with the * symbol, so we set sync_token=*.
- The use of resource_types='["all", "-projects"]' allows us to specify that we want everything but projects.

We then get back the following results:

- All of the resource items except projects.
- A special flag full_sync which is set to true here, and denotes we did a full sync.
- A new sync_token which we can use later on, in order to do incremental syncs.
- An empty temp_id_mapping object which we’ll look at later on.

## Add a new project

Let’s create a new project, and observe the result of our action.

### Using curl

We use the sync call, and then specify the following arguments:

- The user’s API token which is set to token=0123456789abcdef0123456789abcdef01234567.
- The sync token that we received on the reply of our previous request, and which denotes that we want an incremental sync, so we set sync_token="aLGJg_2qwBE_kE3j9_Gn6uoKQtvQeyjm7UEz_aVwF8KdriDxw7e_InFZK61h".
- That we want to get back only the projects and not any other data, so we set resource_types='["projects"]'.
- We send a single project_add command that will create a new project, and we specify as the only argument to that command the name of the project which is set to Project1.
- We also need to specify 2 UUIDs: the uuid that that will uniquely identify our command, and the temp_id which is a temporary ID we set to our new project, and we can use that later on to identify it to the server, without a need to know its real ID, which is assigned at the time of creation on the server. Note that in these examples we’re using UUID values, but you could also use a shorter strings containing letters and/or numbers, but you need to make sure they will be random and unique.

In the results we get back, we notice the following data:

- The new project we added is returned as part of the user’s projects.
- The temp_id_mapping object which tells us that the new object with UUID 24a193a7-46f7-4314-b984-27b707bd2331 has a real ID 176637191. Notice that we can use both of these IDs to refer to that project, and while the latter should be used whenever possible, the former can be also utilized on a temporary basis.
- The sync_status object which tells us whether our command with UUID e23db5ec-2f73-478a-a008-1cb4178d2fd1 was successful, or in case of error what exactly was the problem.
- The special flag full_sync which is set to false here, and denotes we did an incremental sync.
A new sync_token which we can use later on to continue doing incremental syncs.

### Using the Python library

We call the api.projects.add() call, supplying the name of the new project, and as a return value we get a new project object. This object holds the newly created project, and we store it in the project1 variable.

This object is only temporary, it only exists on our local state, so in order to ask the server to add it remotely on the system, too, we use the api.commit() call, which does all the work of sending the request to add the project, and getting back the new project’s properties.

Finally we print the new project1 object.

## Add two new tasks

Let’s create two new tasks in one go, and observe the result of our action.

### Using curl

We use the sync call, and then specify the following arguments:

- The user’s API token, same as on the previous requests.
- The sync token that we received as reply on our previous request.
- For this example we get back both projects and items changed since last sync, so we set resource_types='["projects", "items"]'.
- We send two item_add commands that will create a new task each, and we also specify the project_id and the content of each new task, and for one of the tasks we use the temp_id of the previously created project, while for the other task we use the project’s real ID, and we do that just to show that it has the same result.
- We also need to specify the uuid and temp_id, for the two commands and the two new tasks respectively.

In the results we get back, we notice the following:

- An empty projects array, which is expected as no new projects were added by our commands.
- The new tasks we added are returned as part of the user’s items array.
- The temp_id_mapping object which tells us the real IDs of the new tasks, for each of the temp_ids we sent.
- The sync_status object which tells us whether each command was successful.
- The special flag full_sync which is set to false here, and denotes we did an incremental sync.
- A new sync_token which we can use later on to do more incremental syncs.

### Using the Python library

We call the api.items.add() call, supplying the content of each new task and the project it should be added to, and as a return value we get a new item object, that holds the new task, and which we store to a variable. Notice that we can get the project ID from the project1 object we created on the previous step, and specifically from the project1['id'] value.

In order to actually add the tasks on the server, we do an api.commit() call, and so both item objects are populated with the properties these new tasks have.

Finally we print the new task1 and task2 objects.

## Update the content and due date of a task

Let’s update the content and due date of the first task we created in the previous step.

### Using curl

We use the sync call, and then specify the following arguments:

- The user’s API token same as on the previous requests.
- The sync token that we received as reply on our previous request.
- For this example lets get back only items changed since our last sync, so we set resource_types='["items"]'.
- We send an item_update command that will update the task we created earlier, so we specify the id of the task, its new content, and its new due date by setting the due property with a new due date instance.
- We also need to specify the uuid for this command.

In the results we get back, we notice the following:

- The updates to all items since our last sync are returned as part of the user’s items array.
- The updated item which contains a fully populated due object.
- The temp_id_mapping here is empty since no new object was created.
- The sync_status object which tells us whether our command was successful.
- The special flag full_sync which is set to false here, and denotes we did an incremental sync.

### Using the Python library

We call the update() call on the task1 object that we got in the previous step, so we call task1.update(), and we specify the new content=NewTask1 and due='{'string': 'tomorrow at 10:00'} parameters, in order to change these specific properties of the task.

In order to update the task on the server, we do an api.commit() call.

Finally we print the task1 object, which has now its properties automatically updated.
new sync_token which we can use later on to do more incremental syncs.

## Complete a task and delete another task

Let’s complete the task we updated in the previous step, and delete the task we created earlier.

### Using curl

We use the sync call, and then specify the following arguments:

- The user’s API token same as on the previous requests.
- The sync token that we received as reply on our previous request.
- For this example lets get back only items changed since last sync, so we set resource_types='["items"]'.
- We send an item_complete command that will completed the task, and we specify only the ids parameter with the ID of the task, and also we send an item_delete command that will delete the other task, and this command also expects an ids parameter.
- We also need to specify the uuids for these commands.

In the results we get back, we notice the following:

- The updates to all items since our last sync are returned as part of the user’s items array, where we can observe that the task we completed has a checked=1 property which denotes it’s now completed, while the other task has a is_deleted=1 property which denotes it’s now deleted.
- The temp_id_mapping here is empty since no new object was created.
- The sync_status object which tells us whether our command was successful.
- The special flag full_sync which is set to false here, and denotes we did an incremental sync.
- A new sync_token which we can use later on to do more incremental syncs.

### Using the Python library

We call the complete() method on the task1 object that we have already stored from earlier, and also the delete() method on the task2 object.

In order to actually complete and delete the tasks on the server, we do an api.commit() call.

Finally we print the task1 and task2 objects, and we can observe that their checked=1 and is_deleted=1 properties have been set accordingly.

## Add a new task with a note and a reminder

Let’s create a new task, add a new comment, and also set a reminder based on its due date.

### Using curl

We use the sync call, and then specify the following arguments:

- The user’s API token same as on the previous requests.
- The sync token that we received as reply on our previous request.
- For this example lets get back items, notes and reminders, changed since last sync, so we set resource_types='["items", "notes", "reminders"]'.
- We send an item_add command that will add the new task, a note_add command that will add a note to the new task, and we do that by specifying the temp_id of the new task as the item_id for the note_add command, and a reminder_add command that will create a reminder for our task, again using the temp_id of the task as the item_id of the reminder_add command.
- We also need to specify the uuid for all commands.

In the results we get back, we notice the following:

- The updates to all items, notes and reminders since our last sync, are returned as the equivalent arrays, and we can observe all three new objects created.
- The temp_id_mapping here contains the real IDs of the task, note and reminder.
- The sync_status object which tells us whether our commands were successful.
- The special flag full_sync which is set to false here, and denotes we did an incremental sync.
- A new sync_token which we can use later on to do more incremental syncs.

### Using the Python library

We call the api.items.add() method to create the new task. and we store the object in the task3 variable. We then use the value of task3['id'] as the argument to the api.notes.add() and api.reminders.add() methods that create the new note and reminder respectively. And we store the results to the comment3 and reminder3 variables.

In order to actually create all the objects on the server, we do an api.commit() call.

Finally we print the task3, comment3 and reminder3 objects.


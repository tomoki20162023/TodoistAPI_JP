# Sync

Todoist API (also known as the “Sync API”) is specially designed for efficient data sync between clients (e.g. our mobile apps) and Todoist.

All Sync API requests share the same endpoint URL: https://api.todoist.com/sync/v8/sync

Sync API requests should be made in HTTP POST (application/x-www-form-urlencoded). Sync API responses, including errors, will be returned in JSON.

Sync API supports the following features:

- Batching: reading and writing of multiple resources can be done in a single HTTP request. Batch requests help clients reduce the number of network calls needed to sync resources.
- Incremental sync: You only retrieve data that are updated since the last time you performed a sync request.
Refer to limits to learn more about the number of requests/commands you have for the Sync API

## Read resources

Note that the following parameters mostly make sense when sending commands in the shell with curl, and not with the Python library, as many things are automated there. For example by default the Python library fetches all resource types and then always does incremental syncs, so there’s no need to specify most of the following parameters.

To retrieve your user resources, make a Sync API request with the following parameters:

### Incremental sync

Note that the Python library always does incremental syncs under the hood, so there’s no reason to worry about them if you use it.

The Sync API allows clients to retrieve only updated resources, and this is done by using the “synchronization token”, sync_token, in your Sync API request.

On your initial sync request, specify sync_token=* in your request, and all the user’s active resource data will be returned. Todoist API server will also return a new sync_token in the Sync API response.

In your subsequent Sync request, use the sync_token that you received from your previous sync response, and the Todoist API server will return only the updated resource data.

### Response

When the request succeeds, an HTTP 200 response will be returned with a JSON object containing the requested resources and also a new sync_token.

## Write resources

Note that the Python example is only there to show what is the equivalent for sending commands, but actually there’s no need to use that with the Python library, as it has its own object oriented API which is a lot easier to do various things, so many of the parameters mentioned below do not make much sense for the Python library, and instead you can just use the methods described in the following sections.

To write to your user’s Todoist resources, make a Sync API request with the following parameters

## Command UUID

Note that the Python library takes care of sending UUIDs, so there’s no need to worry about them if you use it.

API clients should generate a unique string ID for each command and specify it in the uuid field. The Command UUID will be used for two purposes:

Note that the Python example is only there to show what is the equivalent for sending commands, but actually there’s no need to use that with the Python library, as it has its own object oriented API which is a lot easier to do various things, so many of the parameters mentioned below do not make much sense for the Python library, and instead you can just use the methods described in the following sections.

To write to your user’s Todoist resources, make a Sync API request with the following parameters

## Command UUID

Note that the Python library takes care of sending UUIDs, so there’s no need to worry about them if you use it.

API clients should generate a unique string ID for each command and specify it in the uuid field. The Command UUID will be used for two purposes:

Command result mapping: Each command’s result will be stored in the sync_status field of the response JSON object. The sync_status object has its key mapped to a command’s uuid and its value containing the result of a command.
Command idempotency: Todoist will not execute command that has same UUID as the previously executed commands. This will allow clients to safely retry each command without accidentally performing the command twice.

1. Command result mapping: Each command’s result will be stored in the sync_status field of the response JSON object. The sync_status object has its key mapped to a command’s uuid and its value containing the result of a command.
1. Command idempotency: Todoist will not execute command that has same UUID as the previously executed commands. This will allow clients to safely retry each command without accidentally performing the command twice.

## Temporary resource id

Note that the Python library takes care of handling temporary ids, so there’s no reason to worry about them if you use it.

Some commands depend on the result of previous command. For instance, you have a command sequence: "project_add" and "item_add" which first creates a project and then add a new task to the newly created project. In order to run the later item_add command, we need to obtain the project ID returned from the previous command. Therefore, the normal approach would be to run these two commands in two separate HTTP requests.

The temporary resource ID feature allows you to run two or more dependent commands in a single HTTP request. For commands that are related to creation of resources (i.e. item_add, project_add), you can specify an extra temp_id as a placeholder for the actual ID of the resource. The other commands in the same sequence could directly refer to temp_id if needed.

## Response / Error

The result of command executions will be stored in the following response JSON object field:

The status result of each command execution is in the sync_status dictionary object. The key is a command uuid and the value will be the result status of the command execution. There are two possible values for each command status -

- an “ok” string which signals success of the command
- an error object containings error information of a command.

Please see the adjacent code examples for the possible format of the sync_status.

## Response status codes

The server uses the HTTP status codes to indicate the success or failure of a request. And as is customary in web servers, a 2xx code indicates - success, a 4xx code - an error due to incorrect user provided information, and a 5xx code - an internal, possibly temporary, error.

